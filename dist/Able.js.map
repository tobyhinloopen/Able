{"version":3,"file":"Able.js","sourceRoot":"/","sources":["Able.ts"],"names":[],"mappings":";;AAIA,IAAiB,IAAI,CA4CpB;AA5CD,WAAiB,IAAI;IACnB,SAAgB,OAAO,CAAC,UAA2B,EAAE,SAAwB;QAC3E,SAAS,GAAG,SAAS,CAAC,KAAK,EAAE,CAAC;QAC9B,KAAK,MAAM,OAAO,IAAI,SAAS,EAAE;YAC/B,MAAM,OAAO,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;YACpC,IAAI,OAAO,EAAE;gBACX,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;oBAC5B,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;wBAC/B,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;qBACxB;iBACF;aACF;SACF;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAbe,YAAO,UAatB,CAAA;IAED,SAAgB,aAAa,CAAC,SAAwB;QACpD,MAAM,MAAM,GAAgB,EAAE,CAAC;QAC/B,MAAM,SAAS,GAAa,EAAE,CAAC;QAC/B,KAAK,MAAM,OAAO,IAAI,SAAS,EAAE;YAC/B,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;gBACtB,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;gBACrD,MAAM,CAAC,GAAG,CAAC,GAAG,OAAO,KAAK,KAAK,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;aACzD;iBAAM;gBACL,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;aACzB;SACF;QACD,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;IAC7B,CAAC;IAZe,kBAAa,gBAY5B,CAAA;IAED,SAAgB,WAAW,CAAC,SAAwB,EAAE,MAAmB;QACvE,MAAM,KAAK,GAAG,aAAa,CAAC;QAC5B,OAAO,SAAS;aACb,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,GAAG,EAAE,EAAE,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;aACnG,MAAM,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAC/C,CAAC;IALe,gBAAW,cAK1B,CAAA;IAED,SAAgB,mBAAmB,CAAC,SAAwB,EAAE,iBAAgC;QAC5F,OAAO,iBAAiB,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;IAC7E,CAAC;IAFe,wBAAmB,sBAElC,CAAA;IAED,SAAgB,SAAS,CAAC,gBAA+B,EAAE,iBAAgC;QACzF,OAAO,IAAI,CAAC,mBAAmB,CAAC,gBAAgB,EAAE,iBAAiB,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC;IACpF,CAAC;IAFe,cAAS,YAExB,CAAA;AACH,CAAC,EA5CgB,IAAI,GAAJ,YAAI,KAAJ,YAAI,QA4CpB","sourcesContent":["export type AbleAbilities = string[];\nexport interface IAbleDefinition { [key: string]: AbleAbilities; }\nexport interface IAbleValues { [key: string]: string; }\n\nexport namespace Able {\n  export function flatten(definition: IAbleDefinition, abilities: AbleAbilities): AbleAbilities {\n    abilities = abilities.slice();\n    for (const ability of abilities) {\n      const members = definition[ability];\n      if (members) {\n        for (const member of members) {\n          if (!abilities.includes(member)) {\n            abilities.push(member);\n          }\n        }\n      }\n    }\n    return abilities;\n  }\n\n  export function extractValues(abilities: AbleAbilities): [IAbleValues, AbleAbilities] {\n    const values: IAbleValues = {};\n    const remainder: string[] = [];\n    for (const ability of abilities) {\n      if (ability[0] === \"?\") {\n        const [key, value] = ability.substr(1).split(\"=\", 2);\n        values[key] = typeof value === \"undefined\" ? \"\" : value;\n      } else {\n        remainder.push(ability);\n      }\n    }\n    return [values, remainder];\n  }\n\n  export function applyValues(abilities: AbleAbilities, values: IAbleValues): AbleAbilities {\n    const REGEX = /\\{([^}]+)\\}/;\n    return abilities\n      .map((ability) => ability.replace(REGEX, (original, key) => key in values ? values[key] : original))\n      .filter((ability) => !REGEX.test(ability));\n  }\n\n  export function getMissingAbilities(abilities: AbleAbilities, requiredAbilities: AbleAbilities): AbleAbilities {\n    return requiredAbilities.filter((ability) => !abilities.includes(ability));\n  }\n\n  export function canAccess(appliedAbilities: AbleAbilities, requiredAbilities: AbleAbilities): boolean {\n    return this.getMissingAbilities(appliedAbilities, requiredAbilities).length === 0;\n  }\n}\n"]}