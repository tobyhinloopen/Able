{"version":3,"file":"Able.js","sourceRoot":"/","sources":["Able.ts"],"names":[],"mappings":";;AAIA,MAAa,IAAI;IACR,MAAM,CAAC,OAAO,CAAC,UAA2B,EAAE,SAAwB;QACzE,SAAS,GAAG,SAAS,CAAC,KAAK,EAAE,CAAC;QAC9B,KAAK,MAAM,OAAO,IAAI,SAAS,EAAE;YAC/B,MAAM,OAAO,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;YACpC,IAAI,OAAO,EAAE;gBACX,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;oBAC5B,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;wBAC/B,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;qBACxB;iBACF;aACF;SACF;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAEM,MAAM,CAAC,aAAa,CAAC,SAAwB;QAClD,MAAM,MAAM,GAAgB,EAAE,CAAC;QAC/B,MAAM,SAAS,GAAa,EAAE,CAAC;QAC/B,KAAK,MAAM,OAAO,IAAI,SAAS,EAAE;YAC/B,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;gBACtB,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;gBACrD,MAAM,CAAC,GAAG,CAAC,GAAG,OAAO,KAAK,KAAK,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;aACzD;iBAAM;gBACL,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;aACzB;SACF;QACD,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;IAC7B,CAAC;IAEM,MAAM,CAAC,WAAW,CAAC,SAAwB,EAAE,MAAmB;QACrE,MAAM,KAAK,GAAG,aAAa,CAAC;QAC5B,OAAO,SAAS;aACb,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,GAAG,EAAE,EAAE,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;aACnG,MAAM,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAC/C,CAAC;IAEM,MAAM,CAAC,mBAAmB,CAAC,gBAA+B,EAAE,iBAAgC;QACjG,OAAO,iBAAiB,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,gBAAgB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;IACpF,CAAC;IAEM,MAAM,CAAC,SAAS,CAAC,gBAA+B,EAAE,iBAAgC;QACvF,OAAO,IAAI,CAAC,mBAAmB,CAAC,gBAAgB,EAAE,iBAAiB,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC;IACpF,CAAC;CACF;AA5CD,oBA4CC","sourcesContent":["export type AbleAbilities = string[];\nexport interface IAbleDefinition { [key: string]: AbleAbilities; }\nexport interface IAbleValues { [key: string]: string; }\n\nexport class Able {\n  public static flatten(definition: IAbleDefinition, abilities: AbleAbilities): AbleAbilities {\n    abilities = abilities.slice();\n    for (const ability of abilities) {\n      const members = definition[ability];\n      if (members) {\n        for (const member of members) {\n          if (!abilities.includes(member)) {\n            abilities.push(member);\n          }\n        }\n      }\n    }\n    return abilities;\n  }\n\n  public static extractValues(abilities: AbleAbilities): [IAbleValues, AbleAbilities] {\n    const values: IAbleValues = {};\n    const remainder: string[] = [];\n    for (const ability of abilities) {\n      if (ability[0] === \"?\") {\n        const [key, value] = ability.substr(1).split(\"=\", 2);\n        values[key] = typeof value === \"undefined\" ? \"\" : value;\n      } else {\n        remainder.push(ability);\n      }\n    }\n    return [values, remainder];\n  }\n\n  public static applyValues(abilities: AbleAbilities, values: IAbleValues): AbleAbilities {\n    const REGEX = /\\{([^}]+)\\}/;\n    return abilities\n      .map((ability) => ability.replace(REGEX, (original, key) => key in values ? values[key] : original))\n      .filter((ability) => !REGEX.test(ability));\n  }\n\n  public static getMissingAbilities(appliedAbilities: AbleAbilities, requiredAbilities: AbleAbilities): AbleAbilities {\n    return requiredAbilities.filter((ability) => !appliedAbilities.includes(ability));\n  }\n\n  public static canAccess(appliedAbilities: AbleAbilities, requiredAbilities: AbleAbilities): boolean {\n    return this.getMissingAbilities(appliedAbilities, requiredAbilities).length === 0;\n  }\n}\n"]}